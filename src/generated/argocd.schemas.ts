/**
 * Generated by orval v6.28.2 üç∫
 * Do not edit manually.
 * Consolidate Services
 * Description of all APIs
 * OpenAPI spec version: version not set
 */
export type ApplicationServiceWatchResourceTree200 = {
  error?: RuntimeStreamError;
  result?: V1alpha1ApplicationTree;
};

export type ApplicationServiceWatchResourceTreeParams = {
namespace?: string;
name?: string;
version?: string;
group?: string;
kind?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceWatch200 = {
  error?: RuntimeStreamError;
  result?: V1alpha1ApplicationWatchEvent;
};

export type ApplicationServiceWatchParams = {
/**
 * the application's name.
 */
name?: string;
/**
 * forces application reconciliation if set to 'hard'.
 */
refresh?: string;
/**
 * the project names to restrict returned list applications.
 */
projects?: string[];
/**
 * when specified with a watch call, shows changes that occur after that particular version of a resource.
 */
resourceVersion?: string;
/**
 * the selector to restrict returned list to applications only with matched labels.
 */
selector?: string;
/**
 * the repoURL to restrict returned list applications.
 */
repo?: string;
/**
 * the application's namespace.
 */
appNamespace?: string;
/**
 * the project names to restrict returned list applications (legacy name for backwards-compatibility).
 */
project?: string[];
};

export type RepositoryServiceValidateAccessParams = {
/**
 * Username for accessing repo.
 */
username?: string;
/**
 * Password for accessing repo.
 */
password?: string;
/**
 * Private key data for accessing SSH repository.
 */
sshPrivateKey?: string;
/**
 * Whether to skip certificate or host key validation.
 */
insecure?: boolean;
/**
 * TLS client cert data for accessing HTTPS repository.
 */
tlsClientCertData?: string;
/**
 * TLS client cert key for accessing HTTPS repository.
 */
tlsClientCertKey?: string;
/**
 * The type of the repo.
 */
type?: string;
/**
 * The name of the repo.
 */
name?: string;
/**
 * Whether helm-oci support should be enabled for this repo.
 */
enableOci?: boolean;
/**
 * Github App Private Key PEM data.
 */
githubAppPrivateKey?: string;
/**
 * Github App ID of the app used to access the repo.
 */
githubAppID?: string;
/**
 * Github App Installation ID of the installed GitHub App.
 */
githubAppInstallationID?: string;
/**
 * Github App Enterprise base url if empty will default to https://api.github.com.
 */
githubAppEnterpriseBaseUrl?: string;
/**
 * HTTP/HTTPS proxy to access the repository.
 */
proxy?: string;
/**
 * Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity.
 */
project?: string;
/**
 * Google Cloud Platform service account key.
 */
gcpServiceAccountKey?: string;
/**
 * Whether to force HTTP basic auth.
 */
forceHttpBasicAuth?: boolean;
};

export type RepositoryServiceListRefsParams = {
/**
 * Whether to force a cache refresh on repo's connection state.
 */
forceRefresh?: boolean;
};

export type RepositoryServiceGetHelmChartsParams = {
/**
 * Whether to force a cache refresh on repo's connection state.
 */
forceRefresh?: boolean;
};

export type RepositoryServiceListAppsParams = {
revision?: string;
appName?: string;
appProject?: string;
};

export type RepositoryServiceDeleteRepositoryParams = {
/**
 * Whether to force a cache refresh on repo's connection state.
 */
forceRefresh?: boolean;
};

export type RepositoryServiceGetParams = {
/**
 * Whether to force a cache refresh on repo's connection state.
 */
forceRefresh?: boolean;
};

export type RepositoryServiceCreateRepositoryParams = {
/**
 * Whether to create in upsert mode.
 */
upsert?: boolean;
/**
 * Whether to operate on credential set instead of repository.
 */
credsOnly?: boolean;
};

export type RepositoryServiceListRepositoriesParams = {
/**
 * Repo URL for query.
 */
repo?: string;
/**
 * Whether to force a cache refresh on repo's connection state.
 */
forceRefresh?: boolean;
};

export type RepoCredsServiceCreateRepositoryCredentialsParams = {
/**
 * Whether to create in upsert mode.
 */
upsert?: boolean;
};

export type RepoCredsServiceListRepositoryCredentialsParams = {
/**
 * Repo URL for query.
 */
url?: string;
};

export type ProjectServiceDeleteTokenParams = {
id?: string;
};

export type ProjectServiceListParams = {
name?: string;
};

export type GPGKeyServiceDeleteParams = {
/**
 * The GPG key ID to query for.
 */
keyID?: string;
};

export type GPGKeyServiceCreateParams = {
/**
 * Whether to upsert already existing public keys.
 */
upsert?: boolean;
};

export type GPGKeyServiceListParams = {
/**
 * The GPG key ID to query for.
 */
keyID?: string;
};

export type ClusterServiceDeleteParams = {
server?: string;
name?: string;
/**
 * type is the type of the specified cluster identifier ( "server" - default, "name" ).
 */
'id.type'?: string;
};

export type ClusterServiceUpdateParams = {
updatedFields?: string[];
/**
 * type is the type of the specified cluster identifier ( "server" - default, "name" ).
 */
'id.type'?: string;
};

export type ClusterServiceGetParams = {
server?: string;
name?: string;
/**
 * type is the type of the specified cluster identifier ( "server" - default, "name" ).
 */
'id.type'?: string;
};

export type ClusterServiceCreateParams = {
upsert?: boolean;
};

export type ClusterServiceListParams = {
server?: string;
name?: string;
/**
 * type is the type of the specified cluster identifier ( "server" - default, "name" ).
 */
'id.type'?: string;
/**
 * value holds the cluster server URL or cluster name.
 */
'id.value'?: string;
};

export type CertificateServiceDeleteCertificateParams = {
/**
 * A file-glob pattern (not regular expression) the host name has to match.
 */
hostNamePattern?: string;
/**
 * The type of the certificate to match (ssh or https).
 */
certType?: string;
/**
 * The sub type of the certificate to match (protocol dependent, usually only used for ssh certs).
 */
certSubType?: string;
};

export type CertificateServiceCreateCertificateParams = {
/**
 * Whether to upsert already existing certificates.
 */
upsert?: boolean;
};

export type CertificateServiceListCertificatesParams = {
/**
 * A file-glob pattern (not regular expression) the host name has to match.
 */
hostNamePattern?: string;
/**
 * The type of the certificate to match (ssh or https).
 */
certType?: string;
/**
 * The sub type of the certificate to match (protocol dependent, usually only used for ssh certs).
 */
certSubType?: string;
};

export type ApplicationSetServiceDeleteParams = {
/**
 * The application set namespace. Default empty is argocd control plane namespace.
 */
appsetNamespace?: string;
};

export type ApplicationSetServiceGetParams = {
/**
 * The application set namespace. Default empty is argocd control plane namespace.
 */
appsetNamespace?: string;
};

export type ApplicationSetServiceCreateParams = {
upsert?: boolean;
};

export type ApplicationSetServiceListParams = {
/**
 * the project names to restrict returned list applicationsets.
 */
projects?: string[];
/**
 * the selector to restrict returned list to applications only with matched labels.
 */
selector?: string;
/**
 * The application set namespace. Default empty is argocd control plane namespace.
 */
appsetNamespace?: string;
};

export type ApplicationServiceGetApplicationSyncWindowsParams = {
appNamespace?: string;
project?: string;
};

export type ApplicationServiceUpdateSpecParams = {
validate?: boolean;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceRevisionMetadataParams = {
/**
 * the application's namespace.
 */
appNamespace?: string;
project?: string;
};

export type ApplicationServiceRevisionChartDetailsParams = {
/**
 * the application's namespace.
 */
appNamespace?: string;
project?: string;
};

export type ApplicationServiceListResourceLinksParams = {
namespace?: string;
resourceName?: string;
version?: string;
group?: string;
kind?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceRunResourceActionParams = {
namespace?: string;
resourceName?: string;
version?: string;
group?: string;
kind?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceListResourceActionsParams = {
namespace?: string;
resourceName?: string;
version?: string;
group?: string;
kind?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceDeleteResourceParams = {
namespace?: string;
resourceName?: string;
version?: string;
group?: string;
kind?: string;
force?: boolean;
orphan?: boolean;
appNamespace?: string;
project?: string;
};

export type ApplicationServicePatchResourceParams = {
namespace?: string;
resourceName?: string;
version?: string;
group?: string;
kind?: string;
patchType?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceGetResourceParams = {
namespace?: string;
resourceName?: string;
version?: string;
group?: string;
kind?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServicePodLogs200 = {
  error?: RuntimeStreamError;
  result?: ApplicationLogEntry;
};

export type ApplicationServicePodLogsParams = {
namespace?: string;
container?: string;
sinceSeconds?: string;
/**
 * Represents seconds of UTC time since Unix epoch
1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
9999-12-31T23:59:59Z inclusive.
 */
'sinceTime.seconds'?: string;
/**
 * Non-negative fractions of a second at nanosecond resolution. Negative
second values with fractions must still have non-negative nanos values
that count forward in time. Must be from 0 to 999,999,999
inclusive. This field may be limited in precision depending on context.
 */
'sinceTime.nanos'?: number;
tailLines?: string;
follow?: boolean;
untilTime?: string;
filter?: string;
kind?: string;
group?: string;
resourceName?: string;
previous?: boolean;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceTerminateOperationParams = {
appNamespace?: string;
project?: string;
};

export type ApplicationServiceGetManifestsParams = {
revision?: string;
appNamespace?: string;
project?: string;
sourcePositions?: string[];
revisions?: string[];
};

export type ApplicationServicePodLogs2200 = {
  error?: RuntimeStreamError;
  result?: ApplicationLogEntry;
};

export type ApplicationServicePodLogs2Params = {
namespace?: string;
podName?: string;
container?: string;
sinceSeconds?: string;
/**
 * Represents seconds of UTC time since Unix epoch
1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
9999-12-31T23:59:59Z inclusive.
 */
'sinceTime.seconds'?: string;
/**
 * Non-negative fractions of a second at nanosecond resolution. Negative
second values with fractions must still have non-negative nanos values
that count forward in time. Must be from 0 to 999,999,999
inclusive. This field may be limited in precision depending on context.
 */
'sinceTime.nanos'?: number;
tailLines?: string;
follow?: boolean;
untilTime?: string;
filter?: string;
kind?: string;
group?: string;
resourceName?: string;
previous?: boolean;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceListLinksParams = {
namespace?: string;
project?: string;
};

export type ApplicationServiceListResourceEventsParams = {
resourceNamespace?: string;
resourceName?: string;
resourceUID?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceDeleteParams = {
cascade?: boolean;
propagationPolicy?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceGetParams = {
/**
 * forces application reconciliation if set to 'hard'.
 */
refresh?: string;
/**
 * the project names to restrict returned list applications.
 */
projects?: string[];
/**
 * when specified with a watch call, shows changes that occur after that particular version of a resource.
 */
resourceVersion?: string;
/**
 * the selector to restrict returned list to applications only with matched labels.
 */
selector?: string;
/**
 * the repoURL to restrict returned list applications.
 */
repo?: string;
/**
 * the application's namespace.
 */
appNamespace?: string;
/**
 * the project names to restrict returned list applications (legacy name for backwards-compatibility).
 */
project?: string[];
};

export type ApplicationServiceResourceTreeParams = {
namespace?: string;
name?: string;
version?: string;
group?: string;
kind?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceManagedResourcesParams = {
namespace?: string;
name?: string;
version?: string;
group?: string;
kind?: string;
appNamespace?: string;
project?: string;
};

export type ApplicationServiceUpdateParams = {
validate?: boolean;
project?: string;
};

export type ApplicationServiceCreateParams = {
upsert?: boolean;
validate?: boolean;
};

export type ApplicationServiceListParams = {
/**
 * the application's name.
 */
name?: string;
/**
 * forces application reconciliation if set to 'hard'.
 */
refresh?: string;
/**
 * the project names to restrict returned list applications.
 */
projects?: string[];
/**
 * when specified with a watch call, shows changes that occur after that particular version of a resource.
 */
resourceVersion?: string;
/**
 * the selector to restrict returned list to applications only with matched labels.
 */
selector?: string;
/**
 * the repoURL to restrict returned list applications.
 */
repo?: string;
/**
 * the application's namespace.
 */
appNamespace?: string;
/**
 * the project names to restrict returned list applications (legacy name for backwards-compatibility).
 */
project?: string[];
};

export type V1alpha1ClusterBody = V1alpha1Cluster;

export type ApplicationServicePatchResourceBodyBody = string;

export type V1alpha1ApplicationBody = V1alpha1Application;

export interface VersionVersionMessage {
  BuildDate?: string;
  Compiler?: string;
  ExtraBuildInfo?: string;
  GitCommit?: string;
  GitTag?: string;
  GitTreeState?: string;
  GoVersion?: string;
  HelmVersion?: string;
  JsonnetVersion?: string;
  KubectlVersion?: string;
  KustomizeVersion?: string;
  Platform?: string;
  Version?: string;
}

export interface V1alpha1TagFilter {
  key?: string;
  value?: string;
}

export interface V1alpha1TLSClientConfig {
  caData?: string;
  certData?: string;
  /** Insecure specifies that the server should be accessed without verifying the TLS certificate. For testing only. */
  insecure?: boolean;
  keyData?: string;
  /** ServerName is passed to the server for SNI and is used in the client to check server
certificates against. If ServerName is empty, the hostname used to contact the
server is used. */
  serverName?: string;
}

export interface V1alpha1SyncWindow {
  applications?: string[];
  clusters?: string[];
  duration?: string;
  kind?: string;
  manualSync?: boolean;
  namespaces?: string[];
  schedule?: string;
  timeZone?: string;
}

export interface V1alpha1SyncStrategyApply {
  /** Force indicates whether or not to supply the --force flag to `kubectl apply`.
The --force flag deletes and re-create the resource, when PATCH encounters conflict and has
retried for 5 times. */
  force?: boolean;
}

/**
 * SyncStrategyHook will perform a sync using hooks annotations.
If no hook annotation is specified falls back to `kubectl apply`.
 */
export interface V1alpha1SyncStrategyHook {
  syncStrategyApply?: V1alpha1SyncStrategyApply;
}

export interface V1alpha1SyncStrategy {
  apply?: V1alpha1SyncStrategyApply;
  hook?: V1alpha1SyncStrategyHook;
}

export interface V1alpha1SyncStatus {
  comparedTo?: V1alpha1ComparedTo;
  revision?: string;
  revisions?: string[];
  status?: string;
}

export interface V1alpha1SyncPolicyAutomated {
  allowEmpty?: boolean;
  prune?: boolean;
  selfHeal?: boolean;
}

export interface V1alpha1SyncPolicy {
  automated?: V1alpha1SyncPolicyAutomated;
  managedNamespaceMetadata?: V1alpha1ManagedNamespaceMetadata;
  retry?: V1alpha1RetryStrategy;
  syncOptions?: string[];
}

export interface V1alpha1SyncOperationResult {
  managedNamespaceMetadata?: V1alpha1ManagedNamespaceMetadata;
  resources?: V1alpha1ResourceResult[];
  revision?: string;
  revisions?: string[];
  source?: V1alpha1ApplicationSource;
  sources?: V1alpha1ApplicationSource[];
}

/**
 * SyncOperationResource contains resources to sync.
 */
export interface V1alpha1SyncOperationResource {
  group?: string;
  kind?: string;
  name?: string;
  namespace?: string;
}

/**
 * SyncOperation contains details about a sync operation.
 */
export interface V1alpha1SyncOperation {
  dryRun?: boolean;
  manifests?: string[];
  prune?: boolean;
  resources?: V1alpha1SyncOperationResource[];
  /** Revision is the revision (Git) or chart version (Helm) which to sync the application to
If omitted, will use the revision specified in app spec. */
  revision?: string;
  /** Revisions is the list of revision (Git) or chart version (Helm) which to sync each source in sources field for the application to
If omitted, will use the revision specified in app spec. */
  revisions?: string[];
  source?: V1alpha1ApplicationSource;
  sources?: V1alpha1ApplicationSource[];
  syncOptions?: string[];
  syncStrategy?: V1alpha1SyncStrategy;
}

export interface V1alpha1SignatureKey {
  keyID?: string;
}

/**
 * Utility struct for a reference to a secret key.
 */
export interface V1alpha1SecretRef {
  key?: string;
  secretName?: string;
}

/**
 * SCMProviderGeneratorGitlab defines connection info specific to Gitlab.
 */
export interface V1alpha1SCMProviderGeneratorGitlab {
  /** Scan all branches instead of just the default branch. */
  allBranches?: boolean;
  /** The Gitlab API URL to talk to. */
  api?: string;
  /** Gitlab group to scan. Required.  You can use either the project id (recommended) or the full namespaced path. */
  group?: string;
  includeSharedProjects?: boolean;
  includeSubgroups?: boolean;
  insecure?: boolean;
  tokenRef?: V1alpha1SecretRef;
  /** Filter repos list based on Gitlab Topic. */
  topic?: string;
}

/**
 * SCMProviderGeneratorGithub defines connection info specific to GitHub.
 */
export interface V1alpha1SCMProviderGeneratorGithub {
  /** Scan all branches instead of just the default branch. */
  allBranches?: boolean;
  /** The GitHub API URL to talk to. If blank, use https://api.github.com/. */
  api?: string;
  /** AppSecretName is a reference to a GitHub App repo-creds secret. */
  appSecretName?: string;
  /** GitHub org to scan. Required. */
  organization?: string;
  tokenRef?: V1alpha1SecretRef;
}

/**
 * SCMProviderGeneratorGitea defines a connection info specific to Gitea.
 */
export interface V1alpha1SCMProviderGeneratorGitea {
  /** Scan all branches instead of just the default branch. */
  allBranches?: boolean;
  /** The Gitea URL to talk to. For example https://gitea.mydomain.com/. */
  api?: string;
  insecure?: boolean;
  /** Gitea organization or user to scan. Required. */
  owner?: string;
  tokenRef?: V1alpha1SecretRef;
}

/**
 * SCMProviderGeneratorFilter is a single repository filter.
If multiple filter types are set on a single struct, they will be AND'd together. All filters must
pass for a repo to be included.
 */
export interface V1alpha1SCMProviderGeneratorFilter {
  /** A regex which must match the branch name. */
  branchMatch?: string;
  /** A regex which must match at least one label. */
  labelMatch?: string;
  /** An array of paths, all of which must not exist. */
  pathsDoNotExist?: string[];
  /** An array of paths, all of which must exist. */
  pathsExist?: string[];
  /** A regex for repo names. */
  repositoryMatch?: string;
}

/**
 * SCMProviderGeneratorBitbucketServer defines connection info specific to Bitbucket Server.
 */
export interface V1alpha1SCMProviderGeneratorBitbucketServer {
  /** Scan all branches instead of just the default branch. */
  allBranches?: boolean;
  /** The Bitbucket Server REST API URL to talk to. Required. */
  api?: string;
  basicAuth?: V1alpha1BasicAuthBitbucketServer;
  /** Project to scan. Required. */
  project?: string;
}

/**
 * SCMProviderGeneratorBitbucket defines connection info specific to Bitbucket Cloud (API version 2).
 */
export interface V1alpha1SCMProviderGeneratorBitbucket {
  /** Scan all branches instead of just the main branch. */
  allBranches?: boolean;
  appPasswordRef?: V1alpha1SecretRef;
  /** Bitbucket workspace to scan. Required. */
  owner?: string;
  user?: string;
}

/**
 * SCMProviderGeneratorAzureDevOps defines connection info specific to Azure DevOps.
 */
export interface V1alpha1SCMProviderGeneratorAzureDevOps {
  accessTokenRef?: V1alpha1SecretRef;
  /** Scan all branches instead of just the default branch. */
  allBranches?: boolean;
  /** The URL to Azure DevOps. If blank, use https://dev.azure.com. */
  api?: string;
  /** Azure Devops organization. Required. E.g. "my-organization". */
  organization?: string;
  /** Azure Devops team project. Required. E.g. "my-team". */
  teamProject?: string;
}

/**
 * SCMProviderGeneratorAWSCodeCommit defines connection info specific to AWS CodeCommit.
 */
export interface V1alpha1SCMProviderGeneratorAWSCodeCommit {
  /** Scan all branches instead of just the default branch. */
  allBranches?: boolean;
  /** Region provides the AWS region to discover repos.
if not provided, AppSet controller will infer the current region from environment. */
  region?: string;
  /** Role provides the AWS IAM role to assume, for cross-account repo discovery
if not provided, AppSet controller will use its pod/node identity to discover. */
  role?: string;
  tagFilters?: V1alpha1TagFilter[];
}

export type V1alpha1SCMProviderGeneratorValues = {[key: string]: string};

/**
 * SCMProviderGenerator defines a generator that scrapes a SCMaaS API to find candidate repos.
 */
export interface V1alpha1SCMProviderGenerator {
  awsCodeCommit?: V1alpha1SCMProviderGeneratorAWSCodeCommit;
  azureDevOps?: V1alpha1SCMProviderGeneratorAzureDevOps;
  bitbucket?: V1alpha1SCMProviderGeneratorBitbucket;
  bitbucketServer?: V1alpha1SCMProviderGeneratorBitbucketServer;
  /** Which protocol to use for the SCM URL. Default is provider-specific but ssh if possible. Not all providers
necessarily support all protocols. */
  cloneProtocol?: string;
  /** Filters for which repos should be considered. */
  filters?: V1alpha1SCMProviderGeneratorFilter[];
  gitea?: V1alpha1SCMProviderGeneratorGitea;
  github?: V1alpha1SCMProviderGeneratorGithub;
  gitlab?: V1alpha1SCMProviderGeneratorGitlab;
  /** Standard parameters. */
  requeueAfterSeconds?: number;
  template?: V1alpha1ApplicationSetTemplate;
  values?: V1alpha1SCMProviderGeneratorValues;
}

export interface V1alpha1RevisionMetadata {
  author?: string;
  date?: V1Time;
  /** Message contains the message associated with the revision, most likely the commit message. */
  message?: string;
  /** SignatureInfo contains a hint on the signer if the revision was signed with GPG, and signature verification is enabled. */
  signatureInfo?: string;
  tags?: string[];
}

export interface V1alpha1RevisionHistory {
  deployedAt?: V1Time;
  deployStartedAt?: V1Time;
  id?: number;
  initiatedBy?: V1alpha1OperationInitiator;
  revision?: string;
  revisions?: string[];
  source?: V1alpha1ApplicationSource;
  sources?: V1alpha1ApplicationSource[];
}

export interface V1alpha1RetryStrategy {
  backoff?: V1alpha1Backoff;
  /** Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed. */
  limit?: number;
}

export interface V1alpha1ResourceStatus {
  group?: string;
  health?: V1alpha1HealthStatus;
  hook?: boolean;
  kind?: string;
  name?: string;
  namespace?: string;
  requiresPruning?: boolean;
  status?: string;
  syncWave?: number;
  version?: string;
}

export interface V1alpha1ResourceResult {
  group?: string;
  /** HookPhase contains the state of any operation associated with this resource OR hook
This can also contain values for non-hook resources. */
  hookPhase?: string;
  hookType?: string;
  kind?: string;
  message?: string;
  name?: string;
  namespace?: string;
  status?: string;
  syncPhase?: string;
  version?: string;
}

export interface V1alpha1ResourceRef {
  group?: string;
  kind?: string;
  name?: string;
  namespace?: string;
  uid?: string;
  version?: string;
}

export interface V1alpha1OverrideIgnoreDiff {
  jqPathExpressions?: string[];
  jSONPointers?: string[];
  managedFieldsManagers?: string[];
}

export interface V1alpha1ResourceOverride {
  actions?: string;
  healthLua?: string;
  ignoreDifferences?: V1alpha1OverrideIgnoreDiff;
  ignoreResourceUpdates?: V1alpha1OverrideIgnoreDiff;
  knownTypeFields?: V1alpha1KnownTypeField[];
  useOpenLibs?: boolean;
}

export type V1alpha1ResourceNode = V1alpha1ResourceRef & {
  createdAt?: V1Time;
  health?: V1alpha1HealthStatus;
  images?: string[];
  info?: V1alpha1InfoItem[];
  networkingInfo?: V1alpha1ResourceNetworkingInfo;
  parentRefs?: V1alpha1ResourceRef[];
  resourceVersion?: string;
};

export type V1alpha1ResourceNetworkingInfoTargetLabels = {[key: string]: string};

export type V1alpha1ResourceNetworkingInfoLabels = {[key: string]: string};

export interface V1alpha1ResourceNetworkingInfo {
  /** ExternalURLs holds list of URLs which should be available externally. List is populated for ingress resources using rules hostnames. */
  externalURLs?: string[];
  ingress?: V1LoadBalancerIngress[];
  labels?: V1alpha1ResourceNetworkingInfoLabels;
  targetLabels?: V1alpha1ResourceNetworkingInfoTargetLabels;
  targetRefs?: V1alpha1ResourceRef[];
}

/**
 * ResourceIgnoreDifferences contains resource filter and list of json paths which should be ignored during comparison with live state.
 */
export interface V1alpha1ResourceIgnoreDifferences {
  group?: string;
  jqPathExpressions?: string[];
  jsonPointers?: string[];
  kind?: string;
  managedFieldsManagers?: string[];
  name?: string;
  namespace?: string;
}

export interface V1alpha1ResourceDiff {
  diff?: string;
  group?: string;
  hook?: boolean;
  kind?: string;
  liveState?: string;
  modified?: boolean;
  name?: string;
  namespace?: string;
  normalizedLiveState?: string;
  predictedLiveState?: string;
  resourceVersion?: string;
  targetState?: string;
}

export interface V1alpha1ResourceActionParam {
  default?: string;
  name?: string;
  type?: string;
  value?: string;
}

export interface V1alpha1ResourceAction {
  disabled?: boolean;
  displayName?: string;
  iconClass?: string;
  name?: string;
  params?: V1alpha1ResourceActionParam[];
}

export interface V1alpha1RepositoryCertificate {
  certData?: string;
  certInfo?: string;
  certSubType?: string;
  certType?: string;
  serverName?: string;
}

export interface V1alpha1RepositoryCertificateList {
  items?: V1alpha1RepositoryCertificate[];
  metadata?: V1ListMeta;
}

export interface V1alpha1Repository {
  connectionState?: V1alpha1ConnectionState;
  /** EnableLFS specifies whether git-lfs support should be enabled for this repo. Only valid for Git repositories. */
  enableLfs?: boolean;
  enableOCI?: boolean;
  forceHttpBasicAuth?: boolean;
  gcpServiceAccountKey?: string;
  githubAppEnterpriseBaseUrl?: string;
  githubAppID?: number;
  githubAppInstallationID?: number;
  githubAppPrivateKey?: string;
  inheritedCreds?: boolean;
  insecure?: boolean;
  insecureIgnoreHostKey?: boolean;
  name?: string;
  password?: string;
  project?: string;
  proxy?: string;
  repo?: string;
  /** SSHPrivateKey contains the PEM data for authenticating at the repo server. Only used with Git repos. */
  sshPrivateKey?: string;
  tlsClientCertData?: string;
  tlsClientCertKey?: string;
  /** Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent. */
  type?: string;
  username?: string;
}

/**
 * RepositoryList is a collection of Repositories.
 */
export interface V1alpha1RepositoryList {
  items?: V1alpha1Repository[];
  metadata?: V1ListMeta;
}

export interface V1alpha1RepoCreds {
  enableOCI?: boolean;
  forceHttpBasicAuth?: boolean;
  gcpServiceAccountKey?: string;
  githubAppEnterpriseBaseUrl?: string;
  githubAppID?: number;
  githubAppInstallationID?: number;
  githubAppPrivateKey?: string;
  password?: string;
  proxy?: string;
  sshPrivateKey?: string;
  tlsClientCertData?: string;
  tlsClientCertKey?: string;
  /** Type specifies the type of the repoCreds. Can be either "git" or "helm. "git" is assumed if empty or absent. */
  type?: string;
  url?: string;
  username?: string;
}

/**
 * RepositoryList is a collection of Repositories.
 */
export interface V1alpha1RepoCredsList {
  items?: V1alpha1RepoCreds[];
  metadata?: V1ListMeta;
}

/**
 * PullRequestGenerator defines connection info specific to GitHub.
 */
export interface V1alpha1PullRequestGeneratorGithub {
  /** The GitHub API URL to talk to. If blank, use https://api.github.com/. */
  api?: string;
  /** AppSecretName is a reference to a GitHub App repo-creds secret with permission to access pull requests. */
  appSecretName?: string;
  labels?: string[];
  /** GitHub org or user to scan. Required. */
  owner?: string;
  /** GitHub repo name to scan. Required. */
  repo?: string;
  tokenRef?: V1alpha1SecretRef;
}

/**
 * PullRequestGeneratorGitea defines connection info specific to Gitea.
 */
export interface V1alpha1PullRequestGeneratorGitea {
  api?: string;
  /** Allow insecure tls, for self-signed certificates; default: false. */
  insecure?: boolean;
  /** Gitea org or user to scan. Required. */
  owner?: string;
  /** Gitea repo name to scan. Required. */
  repo?: string;
  tokenRef?: V1alpha1SecretRef;
}

/**
 * PullRequestGeneratorGitLab defines connection info specific to GitLab.
 */
export interface V1alpha1PullRequestGeneratorGitLab {
  /** The GitLab API URL to talk to. If blank, uses https://gitlab.com/. */
  api?: string;
  insecure?: boolean;
  labels?: string[];
  /** GitLab project to scan. Required. */
  project?: string;
  pullRequestState?: string;
  tokenRef?: V1alpha1SecretRef;
}

/**
 * PullRequestGeneratorFilter is a single pull request filter.
If multiple filter types are set on a single struct, they will be AND'd together. All filters must
pass for a pull request to be included.
 */
export interface V1alpha1PullRequestGeneratorFilter {
  branchMatch?: string;
  targetBranchMatch?: string;
}

/**
 * PullRequestGeneratorBitbucketServer defines connection info specific to BitbucketServer.
 */
export interface V1alpha1PullRequestGeneratorBitbucketServer {
  /** The Bitbucket REST API URL to talk to e.g. https://bitbucket.org/rest Required. */
  api?: string;
  basicAuth?: V1alpha1BasicAuthBitbucketServer;
  /** Project to scan. Required. */
  project?: string;
  /** Repo name to scan. Required. */
  repo?: string;
}

/**
 * PullRequestGeneratorBitbucket defines connection info specific to Bitbucket.
 */
export interface V1alpha1PullRequestGeneratorBitbucket {
  /** The Bitbucket REST API URL to talk to. If blank, uses https://api.bitbucket.org/2.0. */
  api?: string;
  basicAuth?: V1alpha1BasicAuthBitbucketServer;
  bearerToken?: V1alpha1BearerTokenBitbucketCloud;
  /** Workspace to scan. Required. */
  owner?: string;
  /** Repo name to scan. Required. */
  repo?: string;
}

/**
 * PullRequestGeneratorAzureDevOps defines connection info specific to AzureDevOps.
 */
export interface V1alpha1PullRequestGeneratorAzureDevOps {
  /** The Azure DevOps API URL to talk to. If blank, use https://dev.azure.com/. */
  api?: string;
  labels?: string[];
  /** Azure DevOps org to scan. Required. */
  organization?: string;
  /** Azure DevOps project name to scan. Required. */
  project?: string;
  /** Azure DevOps repo name to scan. Required. */
  repo?: string;
  tokenRef?: V1alpha1SecretRef;
}

/**
 * PullRequestGenerator defines a generator that scrapes a PullRequest API to find candidate pull requests.
 */
export interface V1alpha1PullRequestGenerator {
  azuredevops?: V1alpha1PullRequestGeneratorAzureDevOps;
  bitbucket?: V1alpha1PullRequestGeneratorBitbucket;
  bitbucketServer?: V1alpha1PullRequestGeneratorBitbucketServer;
  /** Filters for which pull requests should be considered. */
  filters?: V1alpha1PullRequestGeneratorFilter[];
  gitea?: V1alpha1PullRequestGeneratorGitea;
  github?: V1alpha1PullRequestGeneratorGithub;
  gitlab?: V1alpha1PullRequestGeneratorGitLab;
  /** Standard parameters. */
  requeueAfterSeconds?: number;
  template?: V1alpha1ApplicationSetTemplate;
}

export interface V1alpha1ProjectRole {
  description?: string;
  groups?: string[];
  jwtTokens?: V1alpha1JWTToken[];
  name?: string;
  policies?: string[];
}

/**
 * Parameters contains the information to pass to the plugin. It is a map. The keys must be strings, and the
values can be any type.
 */
export type V1alpha1PluginInputParameters = {[key: string]: V1JSON};

export interface V1alpha1PluginInput {
  /** Parameters contains the information to pass to the plugin. It is a map. The keys must be strings, and the
values can be any type. */
  parameters?: V1alpha1PluginInputParameters;
}

/**
 * Values contains key/value pairs which are passed directly as parameters to the template. These values will not be
sent as parameters to the plugin.
 */
export type V1alpha1PluginGeneratorValues = {[key: string]: string};

export interface V1alpha1PluginConfigMapRef {
  name?: string;
}

/**
 * PluginGenerator defines connection info specific to Plugin.
 */
export interface V1alpha1PluginGenerator {
  configMapRef?: V1alpha1PluginConfigMapRef;
  input?: V1alpha1PluginInput;
  /** RequeueAfterSeconds determines how long the ApplicationSet controller will wait before reconciling the ApplicationSet again. */
  requeueAfterSeconds?: number;
  template?: V1alpha1ApplicationSetTemplate;
  /** Values contains key/value pairs which are passed directly as parameters to the template. These values will not be
sent as parameters to the plugin. */
  values?: V1alpha1PluginGeneratorValues;
}

export interface V1alpha1OrphanedResourceKey {
  group?: string;
  kind?: string;
  name?: string;
}

export interface V1alpha1OrphanedResourcesMonitorSettings {
  ignore?: V1alpha1OrphanedResourceKey[];
  warn?: boolean;
}

export interface V1alpha1OperationInitiator {
  /** Automated is set to true if operation was initiated automatically by the application controller. */
  automated?: boolean;
  username?: string;
}

export interface V1alpha1Operation {
  info?: V1alpha1Info[];
  initiatedBy?: V1alpha1OperationInitiator;
  retry?: V1alpha1RetryStrategy;
  sync?: V1alpha1SyncOperation;
}

export interface V1alpha1OperationState {
  finishedAt?: V1Time;
  /** Message holds any pertinent messages when attempting to perform operation (typically errors). */
  message?: string;
  operation?: V1alpha1Operation;
  phase?: string;
  retryCount?: number;
  startedAt?: V1Time;
  syncResult?: V1alpha1SyncOperationResult;
}

/**
 * MergeGenerator merges the output of two or more generators. Where the values for all specified merge keys are equal
between two sets of generated parameters, the parameter sets will be merged with the parameters from the latter
generator taking precedence. Parameter sets with merge keys not present in the base generator's params will be
ignored.
For example, if the first generator produced [{a: '1', b: '2'}, {c: '1', d: '1'}] and the second generator produced
[{'a': 'override'}], the united parameters for merge keys = ['a'] would be
[{a: 'override', b: '1'}, {c: '1', d: '1'}].

MergeGenerator supports template overriding. If a MergeGenerator is one of multiple top-level generators, its
template will be merged with the top-level generator before the parameters are applied.
 */
export interface V1alpha1MergeGenerator {
  generators?: V1alpha1ApplicationSetNestedGenerator[];
  mergeKeys?: string[];
  template?: V1alpha1ApplicationSetTemplate;
}

/**
 * MatrixGenerator generates the cartesian product of two sets of parameters. The parameters are defined by two nested
generators.
 */
export interface V1alpha1MatrixGenerator {
  generators?: V1alpha1ApplicationSetNestedGenerator[];
  template?: V1alpha1ApplicationSetTemplate;
}

export type V1alpha1ManagedNamespaceMetadataLabels = {[key: string]: string};

export type V1alpha1ManagedNamespaceMetadataAnnotations = {[key: string]: string};

export interface V1alpha1ManagedNamespaceMetadata {
  annotations?: V1alpha1ManagedNamespaceMetadataAnnotations;
  labels?: V1alpha1ManagedNamespaceMetadataLabels;
}

export interface V1alpha1ListGenerator {
  elements?: V1JSON[];
  elementsYaml?: string;
  template?: V1alpha1ApplicationSetTemplate;
}

export interface V1alpha1KustomizeResId {
  gvk?: V1alpha1KustomizeGvk;
  name?: string;
  namespace?: string;
}

export interface V1alpha1KustomizeSelector {
  annotationSelector?: string;
  labelSelector?: string;
  resId?: V1alpha1KustomizeResId;
}

export interface V1alpha1KustomizeReplica {
  count?: IntstrIntOrString;
  name?: string;
}

export type V1alpha1KustomizePatchOptions = {[key: string]: boolean};

export interface V1alpha1KustomizePatch {
  options?: V1alpha1KustomizePatchOptions;
  patch?: string;
  path?: string;
  target?: V1alpha1KustomizeSelector;
}

export interface V1alpha1KustomizeOptions {
  binaryPath?: string;
  buildOptions?: string;
}

export interface V1alpha1KustomizeGvk {
  group?: string;
  kind?: string;
  version?: string;
}

export interface V1alpha1KnownTypeField {
  field?: string;
  type?: string;
}

export interface V1alpha1JsonnetVar {
  code?: boolean;
  name?: string;
  value?: string;
}

export interface V1alpha1JWTToken {
  exp?: number;
  iat?: number;
  id?: string;
}

export interface V1alpha1JWTTokens {
  items?: V1alpha1JWTToken[];
}

export interface V1alpha1InfoItem {
  /** Name is a human readable title for this piece of information. */
  name?: string;
  /** Value is human readable content. */
  value?: string;
}

export interface V1alpha1Info {
  name?: string;
  value?: string;
}

export interface V1alpha1HostResourceInfo {
  capacity?: number;
  requestedByApp?: number;
  requestedByNeighbors?: number;
  resourceName?: string;
}

export interface V1alpha1HostInfo {
  name?: string;
  resourcesInfo?: V1alpha1HostResourceInfo[];
  systemInfo?: V1NodeSystemInfo;
}

export interface V1alpha1HelmParameter {
  forceString?: boolean;
  name?: string;
  value?: string;
}

export interface V1alpha1HelmFileParameter {
  name?: string;
  path?: string;
}

export interface V1alpha1HealthStatus {
  message?: string;
  status?: string;
}

export interface V1alpha1GnuPGPublicKey {
  fingerprint?: string;
  keyData?: string;
  keyID?: string;
  owner?: string;
  subType?: string;
  trust?: string;
}

export interface V1alpha1GnuPGPublicKeyList {
  items?: V1alpha1GnuPGPublicKey[];
  metadata?: V1ListMeta;
}

export type V1alpha1GitGeneratorValues = {[key: string]: string};

export interface V1alpha1GitFileGeneratorItem {
  path?: string;
}

export interface V1alpha1GitDirectoryGeneratorItem {
  exclude?: boolean;
  path?: string;
}

export interface V1alpha1GitGenerator {
  directories?: V1alpha1GitDirectoryGeneratorItem[];
  files?: V1alpha1GitFileGeneratorItem[];
  pathParamPrefix?: string;
  repoURL?: string;
  requeueAfterSeconds?: number;
  revision?: string;
  template?: V1alpha1ApplicationSetTemplate;
  values?: V1alpha1GitGeneratorValues;
}

export type V1alpha1ExecProviderConfigEnv = {[key: string]: string};

export interface V1alpha1ExecProviderConfig {
  apiVersion?: string;
  args?: string[];
  command?: string;
  env?: V1alpha1ExecProviderConfigEnv;
  installHint?: string;
}

export type V1alpha1DuckTypeGeneratorValues = {[key: string]: string};

/**
 * DuckType defines a generator to match against clusters registered with ArgoCD.
 */
export interface V1alpha1DuckTypeGenerator {
  configMapRef?: string;
  labelSelector?: V1LabelSelector;
  name?: string;
  requeueAfterSeconds?: number;
  template?: V1alpha1ApplicationSetTemplate;
  values?: V1alpha1DuckTypeGeneratorValues;
}

export interface V1alpha1ConnectionState {
  attemptedAt?: V1Time;
  message?: string;
  status?: string;
}

export interface V1alpha1ComparedTo {
  destination?: V1alpha1ApplicationDestination;
  ignoreDifferences?: V1alpha1ResourceIgnoreDifferences[];
  source?: V1alpha1ApplicationSource;
  sources?: V1alpha1ApplicationSource[];
}

export interface V1alpha1Command {
  args?: string[];
  command?: string[];
}

export interface V1alpha1ConfigManagementPlugin {
  generate?: V1alpha1Command;
  init?: V1alpha1Command;
  lockRepo?: boolean;
  name?: string;
}

/**
 * ClusterList is a collection of Clusters.
 */
export interface V1alpha1ClusterList {
  items?: V1alpha1Cluster[];
  metadata?: V1ListMeta;
}

export interface V1alpha1ClusterInfo {
  apiVersions?: string[];
  applicationsCount?: number;
  cacheInfo?: V1alpha1ClusterCacheInfo;
  connectionState?: V1alpha1ConnectionState;
  serverVersion?: string;
}

export type V1alpha1ClusterGeneratorValues = {[key: string]: string};

/**
 * ClusterGenerator defines a generator to match against clusters registered with ArgoCD.
 */
export interface V1alpha1ClusterGenerator {
  selector?: V1LabelSelector;
  template?: V1alpha1ApplicationSetTemplate;
  values?: V1alpha1ClusterGeneratorValues;
}

/**
 * ClusterConfig is the configuration attributes. This structure is subset of the go-client
rest.Config with annotations added for marshalling.
 */
export interface V1alpha1ClusterConfig {
  awsAuthConfig?: V1alpha1AWSAuthConfig;
  /** Server requires Bearer authentication. This client will not attempt to use
refresh tokens for an OAuth2 flow.
TODO: demonstrate an OAuth2 compatible client. */
  bearerToken?: string;
  execProviderConfig?: V1alpha1ExecProviderConfig;
  password?: string;
  tlsClientConfig?: V1alpha1TLSClientConfig;
  username?: string;
}

export interface V1alpha1ClusterCacheInfo {
  apisCount?: number;
  lastCacheSyncTime?: V1Time;
  resourcesCount?: number;
}

export type V1alpha1ClusterLabels = {[key: string]: string};

export type V1alpha1ClusterAnnotations = {[key: string]: string};

export interface V1alpha1Cluster {
  annotations?: V1alpha1ClusterAnnotations;
  /** Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode. */
  clusterResources?: boolean;
  config?: V1alpha1ClusterConfig;
  connectionState?: V1alpha1ConnectionState;
  info?: V1alpha1ClusterInfo;
  labels?: V1alpha1ClusterLabels;
  name?: string;
  /** Holds list of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty. */
  namespaces?: string[];
  project?: string;
  refreshRequestedAt?: V1Time;
  server?: string;
  serverVersion?: string;
  /** Shard contains optional shard number. Calculated on the fly by the application controller if not specified. */
  shard?: number;
}

export interface V1alpha1ChartDetails {
  description?: string;
  home?: string;
  maintainers?: string[];
}

/**
 * BearerTokenBitbucketCloud defines the Bearer token for BitBucket AppToken auth.
 */
export interface V1alpha1BearerTokenBitbucketCloud {
  tokenRef?: V1alpha1SecretRef;
}

/**
 * BasicAuthBitbucketServer defines the username/(password or personal access token) for Basic auth.
 */
export interface V1alpha1BasicAuthBitbucketServer {
  passwordRef?: V1alpha1SecretRef;
  username?: string;
}

export interface V1alpha1Backoff {
  duration?: string;
  factor?: number;
  maxDuration?: string;
}

/**
 * ApplicationWatchEvent contains information about application change.
 */
export interface V1alpha1ApplicationWatchEvent {
  application?: V1alpha1Application;
  type?: string;
}

export interface V1alpha1ApplicationTree {
  hosts?: V1alpha1HostInfo[];
  /** Nodes contains list of nodes which either directly managed by the application and children of directly managed nodes. */
  nodes?: V1alpha1ResourceNode[];
  /** OrphanedNodes contains if or orphaned nodes: nodes which are not managed by the app but in the same namespace. List is populated only if orphaned resources enabled in app project. */
  orphanedNodes?: V1alpha1ResourceNode[];
}

export interface V1alpha1ApplicationSummary {
  /** ExternalURLs holds all external URLs of application child resources. */
  externalURLs?: string[];
  /** Images holds all images of application child resources. */
  images?: string[];
}

export interface V1alpha1ApplicationStatus {
  conditions?: V1alpha1ApplicationCondition[];
  controllerNamespace?: string;
  health?: V1alpha1HealthStatus;
  history?: V1alpha1RevisionHistory[];
  observedAt?: V1Time;
  operationState?: V1alpha1OperationState;
  reconciledAt?: V1Time;
  resourceHealthSource?: string;
  resources?: V1alpha1ResourceStatus[];
  sourceType?: string;
  sourceTypes?: string[];
  summary?: V1alpha1ApplicationSummary;
  sync?: V1alpha1SyncStatus;
}

/**
 * ApplicationSpec represents desired application state. Contains link to repository with application definition and additional parameters link definition revision.
 */
export interface V1alpha1ApplicationSpec {
  destination?: V1alpha1ApplicationDestination;
  ignoreDifferences?: V1alpha1ResourceIgnoreDifferences[];
  info?: V1alpha1Info[];
  /** Project is a reference to the project this application belongs to.
The empty string means that application belongs to the 'default' project. */
  project?: string;
  /** RevisionHistoryLimit limits the number of items kept in the application's revision history, which is used for informational purposes as well as for rollbacks to previous versions.
This should only be changed in exceptional circumstances.
Setting to zero will store no history. This will reduce storage used.
Increasing will increase the space used to store the history, so we do not recommend increasing it.
Default is 10. */
  revisionHistoryLimit?: number;
  source?: V1alpha1ApplicationSource;
  sources?: V1alpha1ApplicationSource[];
  syncPolicy?: V1alpha1SyncPolicy;
}

/**
 * Map is the value of a map type parameter.
 */
export type V1alpha1ApplicationSourcePluginParameterMap = {[key: string]: string};

export interface V1alpha1ApplicationSourcePluginParameter {
  /** Array is the value of an array type parameter. */
  array?: string[];
  /** Map is the value of a map type parameter. */
  map?: V1alpha1ApplicationSourcePluginParameterMap;
  /** Name is the name identifying a parameter. */
  name?: string;
  /** String_ is the value of a string type parameter. */
  string?: string;
}

export interface V1alpha1ApplicationSourcePlugin {
  env?: Applicationv1alpha1EnvEntry[];
  name?: string;
  parameters?: V1alpha1ApplicationSourcePluginParameter[];
}

export type V1alpha1ApplicationSourceKustomizeCommonLabels = {[key: string]: string};

export type V1alpha1ApplicationSourceKustomizeCommonAnnotations = {[key: string]: string};

export interface V1alpha1ApplicationSourceKustomize {
  commonAnnotations?: V1alpha1ApplicationSourceKustomizeCommonAnnotations;
  commonAnnotationsEnvsubst?: boolean;
  commonLabels?: V1alpha1ApplicationSourceKustomizeCommonLabels;
  components?: string[];
  forceCommonAnnotations?: boolean;
  forceCommonLabels?: boolean;
  images?: string[];
  labelWithoutSelector?: boolean;
  namePrefix?: string;
  namespace?: string;
  nameSuffix?: string;
  patches?: V1alpha1KustomizePatch[];
  replicas?: V1alpha1KustomizeReplica[];
  version?: string;
}

export interface V1alpha1ApplicationSourceJsonnet {
  extVars?: V1alpha1JsonnetVar[];
  libs?: string[];
  tlas?: V1alpha1JsonnetVar[];
}

export interface V1alpha1ApplicationSourceHelm {
  fileParameters?: V1alpha1HelmFileParameter[];
  ignoreMissingValueFiles?: boolean;
  parameters?: V1alpha1HelmParameter[];
  passCredentials?: boolean;
  releaseName?: string;
  skipCrds?: boolean;
  valueFiles?: string[];
  values?: string;
  valuesObject?: RuntimeRawExtension;
  version?: string;
}

export interface V1alpha1ApplicationSourceDirectory {
  exclude?: string;
  include?: string;
  jsonnet?: V1alpha1ApplicationSourceJsonnet;
  recurse?: boolean;
}

export interface V1alpha1ApplicationSource {
  /** Chart is a Helm chart name, and must be specified for applications sourced from a Helm repo. */
  chart?: string;
  directory?: V1alpha1ApplicationSourceDirectory;
  helm?: V1alpha1ApplicationSourceHelm;
  kustomize?: V1alpha1ApplicationSourceKustomize;
  /** Path is a directory path within the Git repository, and is only valid for applications sourced from Git. */
  path?: string;
  plugin?: V1alpha1ApplicationSourcePlugin;
  /** Ref is reference to another source within sources field. This field will not be used if used with a `source` tag. */
  ref?: string;
  repoURL?: string;
  /** TargetRevision defines the revision of the source to sync the application to.
In case of Git, this can be commit, tag, or branch. If omitted, will equal to HEAD.
In case of Helm, this is a semver tag for the Chart's version. */
  targetRevision?: string;
}

export type V1alpha1ApplicationSetTemplateMetaLabels = {[key: string]: string};

export type V1alpha1ApplicationSetTemplateMetaAnnotations = {[key: string]: string};

export interface V1alpha1ApplicationSetTemplateMeta {
  annotations?: V1alpha1ApplicationSetTemplateMetaAnnotations;
  finalizers?: string[];
  labels?: V1alpha1ApplicationSetTemplateMetaLabels;
  name?: string;
  namespace?: string;
}

export interface V1alpha1ApplicationSetTemplate {
  metadata?: V1alpha1ApplicationSetTemplateMeta;
  spec?: V1alpha1ApplicationSpec;
}

/**
 * ApplicationSetSyncPolicy configures how generated Applications will relate to their
ApplicationSet.
 */
export interface V1alpha1ApplicationSetSyncPolicy {
  applicationsSync?: string;
  /** PreserveResourcesOnDeletion will preserve resources on deletion. If PreserveResourcesOnDeletion is set to true, these Applications will not be deleted. */
  preserveResourcesOnDeletion?: boolean;
}

/**
 * ApplicationSetStrategy configures how generated Applications are updated in sequence.
 */
export interface V1alpha1ApplicationSetStrategy {
  rollingSync?: V1alpha1ApplicationSetRolloutStrategy;
  type?: string;
}

export interface V1alpha1ApplicationSetStatus {
  applicationStatus?: V1alpha1ApplicationSetApplicationStatus[];
  conditions?: V1alpha1ApplicationSetCondition[];
}

/**
 * ApplicationSetSpec represents a class of application set state.
 */
export interface V1alpha1ApplicationSetSpec {
  applyNestedSelectors?: boolean;
  generators?: V1alpha1ApplicationSetGenerator[];
  goTemplate?: boolean;
  goTemplateOptions?: string[];
  ignoreApplicationDifferences?: V1alpha1ApplicationSetResourceIgnoreDifferences[];
  preservedFields?: V1alpha1ApplicationPreservedFields;
  strategy?: V1alpha1ApplicationSetStrategy;
  syncPolicy?: V1alpha1ApplicationSetSyncPolicy;
  template?: V1alpha1ApplicationSetTemplate;
  templatePatch?: string;
}

export interface V1alpha1ApplicationSetRolloutStep {
  matchExpressions?: V1alpha1ApplicationMatchExpression[];
  maxUpdate?: IntstrIntOrString;
}

export interface V1alpha1ApplicationSetRolloutStrategy {
  steps?: V1alpha1ApplicationSetRolloutStep[];
}

/**
 * ApplicationSetResourceIgnoreDifferences configures how the ApplicationSet controller will ignore differences in live
applications when applying changes from generated applications.
 */
export interface V1alpha1ApplicationSetResourceIgnoreDifferences {
  /** JQPathExpressions is a list of JQ path expressions to fields to ignore differences for. */
  jqPathExpressions?: string[];
  /** JSONPointers is a list of JSON pointers to fields to ignore differences for. */
  jsonPointers?: string[];
  /** Name is the name of the application to ignore differences for. If not specified, the rule applies to all applications. */
  name?: string;
}

/**
 * ApplicationSetNestedGenerator represents a generator nested within a combination-type generator (MatrixGenerator or
MergeGenerator).
 */
export interface V1alpha1ApplicationSetNestedGenerator {
  clusterDecisionResource?: V1alpha1DuckTypeGenerator;
  clusters?: V1alpha1ClusterGenerator;
  git?: V1alpha1GitGenerator;
  list?: V1alpha1ListGenerator;
  matrix?: V1JSON;
  merge?: V1JSON;
  plugin?: V1alpha1PluginGenerator;
  pullRequest?: V1alpha1PullRequestGenerator;
  scmProvider?: V1alpha1SCMProviderGenerator;
  selector?: V1LabelSelector;
}

export interface V1alpha1ApplicationSetList {
  items?: V1alpha1ApplicationSet[];
  metadata?: V1ListMeta;
}

/**
 * ApplicationSetGenerator represents a generator at the top level of an ApplicationSet.
 */
export interface V1alpha1ApplicationSetGenerator {
  clusterDecisionResource?: V1alpha1DuckTypeGenerator;
  clusters?: V1alpha1ClusterGenerator;
  git?: V1alpha1GitGenerator;
  list?: V1alpha1ListGenerator;
  matrix?: V1alpha1MatrixGenerator;
  merge?: V1alpha1MergeGenerator;
  plugin?: V1alpha1PluginGenerator;
  pullRequest?: V1alpha1PullRequestGenerator;
  scmProvider?: V1alpha1SCMProviderGenerator;
  selector?: V1LabelSelector;
}

export interface V1alpha1ApplicationSetCondition {
  lastTransitionTime?: V1Time;
  message?: string;
  reason?: string;
  status?: string;
  type?: string;
}

export interface V1alpha1ApplicationSetApplicationStatus {
  application?: string;
  lastTransitionTime?: V1Time;
  message?: string;
  status?: string;
  step?: string;
}

export interface V1alpha1ApplicationSet {
  metadata?: V1ObjectMeta;
  spec?: V1alpha1ApplicationSetSpec;
  status?: V1alpha1ApplicationSetStatus;
}

export interface V1alpha1ApplicationPreservedFields {
  annotations?: string[];
  labels?: string[];
}

export interface V1alpha1ApplicationMatchExpression {
  key?: string;
  operator?: string;
  values?: string[];
}

export interface V1alpha1ApplicationDestination {
  /** Name is an alternate way of specifying the target cluster by its symbolic name. This must be set if Server is not set. */
  name?: string;
  namespace?: string;
  /** Server specifies the URL of the target cluster's Kubernetes control plane API. This must be set if Name is not set. */
  server?: string;
}

export interface V1alpha1Application {
  metadata?: V1ObjectMeta;
  operation?: V1alpha1Operation;
  spec?: V1alpha1ApplicationSpec;
  status?: V1alpha1ApplicationStatus;
}

export interface V1alpha1ApplicationList {
  items?: V1alpha1Application[];
  metadata?: V1ListMeta;
}

export type V1alpha1AppProjectStatusJwtTokensByRole = {[key: string]: V1alpha1JWTTokens};

export interface V1alpha1AppProjectStatus {
  jwtTokensByRole?: V1alpha1AppProjectStatusJwtTokensByRole;
}

export interface V1alpha1AppProjectSpec {
  clusterResourceBlacklist?: V1GroupKind[];
  clusterResourceWhitelist?: V1GroupKind[];
  description?: string;
  destinations?: V1alpha1ApplicationDestination[];
  namespaceResourceBlacklist?: V1GroupKind[];
  namespaceResourceWhitelist?: V1GroupKind[];
  orphanedResources?: V1alpha1OrphanedResourcesMonitorSettings;
  permitOnlyProjectScopedClusters?: boolean;
  roles?: V1alpha1ProjectRole[];
  signatureKeys?: V1alpha1SignatureKey[];
  sourceNamespaces?: string[];
  sourceRepos?: string[];
  syncWindows?: V1alpha1SyncWindow[];
}

export interface V1alpha1AppProject {
  metadata?: V1ObjectMeta;
  spec?: V1alpha1AppProjectSpec;
  status?: V1alpha1AppProjectStatus;
}

export interface V1alpha1AppProjectList {
  items?: V1alpha1AppProject[];
  metadata?: V1ListMeta;
}

export interface V1alpha1AWSAuthConfig {
  clusterName?: string;
  /** Profile contains optional role ARN. If set then AWS IAM Authenticator uses the profile to perform cluster operations instead of the default AWS credential provider chain. */
  profile?: string;
  /** RoleARN contains optional role ARN. If set then AWS IAM Authenticator assume a role to perform cluster operations instead of the default AWS credential provider chain. */
  roleARN?: string;
}

/**
 * Time is a wrapper around time.Time which supports correct
marshaling to YAML and JSON.  Wrappers are provided for many
of the factory methods that the time package offers.

+protobuf.options.marshal=false
+protobuf.as=Timestamp
+protobuf.options.(gogoproto.goproto_stringer)=false
 */
export type V1Time = string;

export interface V1alpha1ApplicationCondition {
  lastTransitionTime?: V1Time;
  message?: string;
  type?: string;
}

export interface V1PortStatus {
  error?: string;
  port?: number;
  protocol?: string;
}

export interface V1OwnerReference {
  /** API version of the referent. */
  apiVersion?: string;
  blockOwnerDeletion?: boolean;
  controller?: boolean;
  kind?: string;
  name?: string;
  uid?: string;
}

/**
 * ObjectReference contains enough information to let you inspect or modify the referred object.
---
New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.
 1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.
 2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular
    restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".
    Those cannot be well described when embedded.
 3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.
 4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity
    during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple
    and the version of the actual struct is irrelevant.
 5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type
    will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control.

Instead of using this type, create a locally provided and used type that is well-focused on your reference.
For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+structType=atomic
 */
export interface V1ObjectReference {
  apiVersion?: string;
  fieldPath?: string;
  kind?: string;
  name?: string;
  namespace?: string;
  resourceVersion?: string;
  uid?: string;
}

export type V1ObjectMetaLabels = {[key: string]: string};

export type V1ObjectMetaAnnotations = {[key: string]: string};

/**
 * NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
 */
export interface V1NodeSystemInfo {
  architecture?: string;
  /** Boot ID reported by the node. */
  bootID?: string;
  /** ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2). */
  containerRuntimeVersion?: string;
  /** Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64). */
  kernelVersion?: string;
  /** Kubelet Version reported by the node. */
  kubeletVersion?: string;
  /** KubeProxy Version reported by the node. */
  kubeProxyVersion?: string;
  machineID?: string;
  operatingSystem?: string;
  /** OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)). */
  osImage?: string;
  systemUUID?: string;
}

/**
 * MicroTime is version of Time with microsecond level precision.

+protobuf.options.marshal=false
+protobuf.as=Timestamp
+protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1MicroTime {
  /** Non-negative fractions of a second at nanosecond resolution. Negative
second values with fractions must still have non-negative nanos values
that count forward in time. Must be from 0 to 999,999,999
inclusive. This field may be limited in precision depending on context. */
  nanos?: number;
  /** Represents seconds of UTC time since Unix epoch
1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
9999-12-31T23:59:59Z inclusive. */
  seconds?: number;
}

/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
that the fieldset applies to.
 */
export interface V1ManagedFieldsEntry {
  /** APIVersion defines the version of this resource that this field set
applies to. The format is "group/version" just like the top-level
APIVersion field. It is necessary to track the version of a field
set because it cannot be automatically converted. */
  apiVersion?: string;
  fieldsType?: string;
  fieldsV1?: V1FieldsV1;
  /** Manager is an identifier of the workflow managing these fields. */
  manager?: string;
  /** Operation is the type of operation which lead to this ManagedFieldsEntry being created.
The only valid values for this field are 'Apply' and 'Update'. */
  operation?: string;
  /** Subresource is the name of the subresource used to update that object, or
empty string if the object was updated through the main resource. The
value of this field is used to distinguish between managers, even if they
share the same name. For example, a status update will be distinct from a
regular update using the same manager name.
Note that the APIVersion field is not related to the Subresource field and
it always corresponds to the version of the main resource. */
  subresource?: string;
  time?: V1Time;
}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects
users must create.
 */
export interface V1ObjectMeta {
  annotations?: V1ObjectMetaAnnotations;
  creationTimestamp?: V1Time;
  deletionGracePeriodSeconds?: number;
  deletionTimestamp?: V1Time;
  finalizers?: string[];
  /** GenerateName is an optional prefix, used by the server, to generate a unique
name ONLY IF the Name field has not been provided.
If this field is used, the name returned to the client will be different
than the name passed. This value will also be combined with a unique suffix.
The provided value has the same validation rules as the Name field,
and may be truncated by the length of the suffix required to make the value
unique on the server.

If this field is specified and the generated name exists, the server will return a 409.

Applied only if Name is not specified.
More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
+optional */
  generateName?: string;
  generation?: number;
  labels?: V1ObjectMetaLabels;
  /** ManagedFields maps workflow-id and version to the set of fields
that are managed by that workflow. This is mostly for internal
housekeeping, and users typically shouldn't need to set or
understand this field. A workflow can be the user's name, a
controller's name, or the name of a specific apply path like
"ci-cd". The set of fields is always in the version that the
workflow used when modifying the object.

+optional */
  managedFields?: V1ManagedFieldsEntry[];
  name?: string;
  /** Namespace defines the space within which each name must be unique. An empty namespace is
equivalent to the "default" namespace, but "default" is the canonical representation.
Not all objects are required to be scoped to a namespace - the value of this field for
those objects will be empty.

Must be a DNS_LABEL.
Cannot be updated.
More info: http://kubernetes.io/docs/user-guide/namespaces
+optional */
  namespace?: string;
  ownerReferences?: V1OwnerReference[];
  /** An opaque value that represents the internal version of this object that can
be used by clients to determine when objects have changed. May be used for optimistic
concurrency, change detection, and the watch operation on a resource or set of resources.
Clients must treat these values as opaque and passed unmodified back to the server.
They may only be valid for a particular resource or set of resources.

Populated by the system.
Read-only.
Value must be treated as opaque by clients and .
More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
+optional */
  resourceVersion?: string;
  selfLink?: string;
  /** UID is the unique in time and space value for this object. It is typically generated by
the server on successful creation of a resource and is not allowed to change on PUT
operations.

Populated by the system.
Read-only.
More info: http://kubernetes.io/docs/user-guide/identifiers#uids
+optional */
  uid?: string;
}

/**
 * LoadBalancerIngress represents the status of a load-balancer ingress point:
traffic intended for the service should be sent to an ingress point.
 */
export interface V1LoadBalancerIngress {
  hostname?: string;
  ip?: string;
  ports?: V1PortStatus[];
}

/**
 * ListMeta describes metadata that synthetic resources must have, including lists and
various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
 */
export interface V1ListMeta {
  /** continue may be set if the user set a limit on the number of items returned, and indicates that
the server has more data available. The value is opaque and may be used to issue another request
to the endpoint that served this list to retrieve the next set of available objects. Continuing a
consistent list may not be possible if the server configuration has changed or more than a few
minutes have passed. The resourceVersion field returned when using this continue value will be
identical to the value in the first response, unless you have received this token from an error
message. */
  continue?: string;
  remainingItemCount?: number;
  resourceVersion?: string;
  selfLink?: string;
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
relates the key and values.
 */
export interface V1LabelSelectorRequirement {
  key?: string;
  /** operator represents a key's relationship to a set of values.
Valid operators are In, NotIn, Exists and DoesNotExist. */
  operator?: string;
  values?: string[];
}

export type V1LabelSelectorMatchLabels = {[key: string]: string};

export interface V1LabelSelector {
  matchExpressions?: V1LabelSelectorRequirement[];
  matchLabels?: V1LabelSelectorMatchLabels;
}

/**
 * JSON represents any valid JSON value.
These types are supported: bool, int64, float64, string, []interface{}, map[string]interface{} and nil.
 */
export interface V1JSON {
  raw?: string;
}

/**
 * +protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1GroupKind {
  group?: string;
  kind?: string;
}

/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.

Each key is either a '.' representing the field itself, and will always map to an empty set,
or a string representing a sub-field or item. The string will follow one of these four formats:
'f:<name>', where <name> is the name of a field in a struct, or key in a map
'v:<value>', where <value> is the exact json formatted value of a list item
'i:<index>', where <index> is position of a item in a list
'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
If a key maps to an empty Fields value, the field that key represents is part of the set.

The exact format is defined in sigs.k8s.io/structured-merge-diff
+protobuf.options.(gogoproto.goproto_stringer)=false
 */
export interface V1FieldsV1 {
  /** Raw is the underlying serialization of this object. */
  Raw?: string;
}

/**
 * EventSource contains information for an event.
 */
export interface V1EventSource {
  component?: string;
  host?: string;
}

/**
 * EventSeries contain information on series of events, i.e. thing that was/is happening
continuously for some time.
 */
export interface V1EventSeries {
  count?: number;
  lastObservedTime?: V1MicroTime;
}

/**
 * Event is a report of an event somewhere in the cluster.  Events
have a limited retention time and triggers and messages may evolve
with time.  Event consumers should not rely on the timing of an event
with a given Reason reflecting a consistent underlying trigger, or the
continued existence of events with that Reason.  Events should be
treated as informative, best-effort, supplemental data.
 */
export interface V1Event {
  action?: string;
  count?: number;
  eventTime?: V1MicroTime;
  firstTimestamp?: V1Time;
  involvedObject?: V1ObjectReference;
  lastTimestamp?: V1Time;
  message?: string;
  metadata?: V1ObjectMeta;
  reason?: string;
  related?: V1ObjectReference;
  reportingComponent?: string;
  reportingInstance?: string;
  series?: V1EventSeries;
  source?: V1EventSource;
  type?: string;
}

/**
 * EventList is a list of events.
 */
export interface V1EventList {
  items?: V1Event[];
  metadata?: V1ListMeta;
}

/**
 * SessionResponse wraps the created token or returns an empty string if deleted.
 */
export interface SessionSessionResponse {
  token?: string;
}

/**
 * SessionCreateRequest is for logging in.
 */
export interface SessionSessionCreateRequest {
  password?: string;
  token?: string;
  username?: string;
}

export interface SessionGetUserInfoResponse {
  groups?: string[];
  iss?: string;
  loggedIn?: boolean;
  username?: string;
}

/**
 * RawExtension is used to hold extensions in external versions.

To use this, make a field which has RawExtension as its type in your external, versioned
struct, and Object in your internal struct. You also need to register your
various plugin types.

// Internal package:

	type MyAPIObject struct {
		runtime.TypeMeta `json:",inline"`
		MyPlugin runtime.Object `json:"myPlugin"`
	}

	type PluginA struct {
		AOption string `json:"aOption"`
	}

// External package:

	type MyAPIObject struct {
		runtime.TypeMeta `json:",inline"`
		MyPlugin runtime.RawExtension `json:"myPlugin"`
	}

	type PluginA struct {
		AOption string `json:"aOption"`
	}

// On the wire, the JSON will look something like this:

	{
		"kind":"MyAPIObject",
		"apiVersion":"v1",
		"myPlugin": {
			"kind":"PluginA",
			"aOption":"foo",
		},
	}

So what happens? Decode first uses json or yaml to unmarshal the serialized data into
your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked.
The next step is to copy (using pkg/conversion) into the internal struct. The runtime
package's DefaultScheme has conversion functions installed which will unpack the
JSON stored in RawExtension, turning it into the correct object type, and storing it
in the Object. (TODO: In the case where the object is of an unknown type, a
runtime.Unknown object will be created and stored.)

+k8s:deepcopy-gen=true
+protobuf=true
+k8s:openapi-gen=true
 */
export interface RuntimeRawExtension {
  /** Raw is the underlying serialization of this object.

TODO: Determine how to detect ContentType and ContentEncoding of 'Raw' data. */
  raw?: string;
}

export interface RuntimeError {
  code?: number;
  details?: ProtobufAny[];
  error?: string;
  message?: string;
}

export interface RepositoryRepoResponse { [key: string]: any }

export interface RepositoryRepoAppsResponse {
  items?: RepositoryAppInfo[];
}

export interface RepositoryRepoAppDetailsQuery {
  appName?: string;
  appProject?: string;
  source?: V1alpha1ApplicationSource;
}

export interface RepositoryRefs {
  branches?: string[];
  tags?: string[];
}

/**
 * map is the default value of the parameter if the parameter is a map.
 */
export type RepositoryParameterAnnouncementMap = {[key: string]: string};

export interface RepositoryParameterAnnouncement {
  /** array is the default value of the parameter if the parameter is an array. */
  array?: string[];
  /** collectionType is the type of value this parameter holds - either a single value (a string) or a collection
(array or map). If collectionType is set, only the field with that type will be used. If collectionType is not
set, `string` is the default. If collectionType is set to an invalid value, a validation error is thrown. */
  collectionType?: string;
  /** itemType determines the primitive data type represented by the parameter. Parameters are always encoded as
strings, but this field lets them be interpreted as other primitive types. */
  itemType?: string;
  /** map is the default value of the parameter if the parameter is a map. */
  map?: RepositoryParameterAnnouncementMap;
  /** name is the name identifying a parameter. */
  name?: string;
  /** required defines if this given parameter is mandatory. */
  required?: boolean;
  /** string is the default value of the parameter if the parameter is a string. */
  string?: string;
  /** title is a human-readable text of the parameter name. */
  title?: string;
  /** tooltip is a human-readable description of the parameter. */
  tooltip?: string;
}

export interface RepositoryPluginAppSpec {
  parametersAnnouncement?: RepositoryParameterAnnouncement[];
}

export interface RepositoryManifestResponse {
  manifests?: string[];
  namespace?: string;
  revision?: string;
  server?: string;
  sourceType?: string;
  verifyResult?: string;
}

export interface RepositoryKustomizeAppSpec {
  /** images is a list of available images. */
  images?: string[];
}

export interface RepositoryRepoAppDetailsResponse {
  directory?: RepositoryDirectoryAppSpec;
  helm?: RepositoryHelmAppSpec;
  kustomize?: RepositoryKustomizeAppSpec;
  plugin?: RepositoryPluginAppSpec;
  type?: string;
}

export interface RepositoryHelmChart {
  name?: string;
  versions?: string[];
}

export interface RepositoryHelmChartsResponse {
  items?: RepositoryHelmChart[];
}

export interface RepositoryHelmAppSpec {
  fileParameters?: V1alpha1HelmFileParameter[];
  name?: string;
  parameters?: V1alpha1HelmParameter[];
  valueFiles?: string[];
  values?: string;
}

export interface RepositoryDirectoryAppSpec { [key: string]: any }

export interface RepositoryAppInfo {
  path?: string;
  type?: string;
}

export interface RepocredsRepoCredsResponse { [key: string]: any }

export interface ProtobufAny {
  type_url?: string;
  value?: string;
}

export interface RuntimeStreamError {
  details?: ProtobufAny[];
  grpc_code?: number;
  http_code?: number;
  http_status?: string;
  message?: string;
}

export interface ProjectSyncWindowsResponse {
  windows?: V1alpha1SyncWindow[];
}

export interface ProjectProjectUpdateRequest {
  project?: V1alpha1AppProject;
}

/**
 * ProjectTokenResponse wraps the created token or returns an empty string if deleted.
 */
export interface ProjectProjectTokenResponse {
  token?: string;
}

/**
 * ProjectTokenCreateRequest defines project token creation parameters.
 */
export interface ProjectProjectTokenCreateRequest {
  description?: string;
  expiresIn?: number;
  id?: string;
  project?: string;
  role?: string;
}

/**
 * ProjectCreateRequest defines project creation parameters.
 */
export interface ProjectProjectCreateRequest {
  project?: V1alpha1AppProject;
  upsert?: boolean;
}

export interface ProjectGlobalProjectsResponse {
  items?: V1alpha1AppProject[];
}

export interface ProjectEmptyResponse { [key: string]: any }

export interface ProjectDetailedProjectsResponse {
  clusters?: V1alpha1Cluster[];
  globalProjects?: V1alpha1AppProject[];
  project?: V1alpha1AppProject;
  repositories?: V1alpha1Repository[];
}

export interface OidcClaim {
  essential?: boolean;
  value?: string;
  values?: string[];
}

export interface NotificationTrigger {
  name?: string;
}

export interface NotificationTriggerList {
  items?: NotificationTrigger[];
}

export interface NotificationTemplate {
  name?: string;
}

export interface NotificationTemplateList {
  items?: NotificationTemplate[];
}

export interface NotificationService {
  name?: string;
}

export interface NotificationServiceList {
  items?: NotificationService[];
}

/**
 * +protobuf=true
+protobuf.options.(gogoproto.goproto_stringer)=false
+k8s:openapi-gen=true
 */
export interface IntstrIntOrString {
  intVal?: number;
  strVal?: string;
  type?: number;
}

export interface GpgkeyGnuPGPublicKeyResponse { [key: string]: any }

export interface GpgkeyGnuPGPublicKeyCreateResponse {
  created?: V1alpha1GnuPGPublicKeyList;
  skipped?: string[];
}

export type ClusterSettingsResourceOverrides = {[key: string]: V1alpha1ResourceOverride};

export interface ClusterPlugin {
  name?: string;
}

export interface ClusterSettingsPluginsResponse {
  plugins?: ClusterPlugin[];
}

export interface ClusterSettings {
  appLabelKey?: string;
  appsInAnyNamespaceEnabled?: boolean;
  /** Deprecated: use sidecar plugins instead. */
  configManagementPlugins?: V1alpha1ConfigManagementPlugin[];
  controllerNamespace?: string;
  dexConfig?: ClusterDexConfig;
  execEnabled?: boolean;
  googleAnalytics?: ClusterGoogleAnalyticsConfig;
  help?: ClusterHelp;
  kustomizeOptions?: V1alpha1KustomizeOptions;
  kustomizeVersions?: string[];
  oidcConfig?: ClusterOIDCConfig;
  passwordPattern?: string;
  plugins?: ClusterPlugin[];
  resourceOverrides?: ClusterSettingsResourceOverrides;
  statusBadgeEnabled?: boolean;
  statusBadgeRootUrl?: string;
  trackingMethod?: string;
  uiBannerContent?: string;
  uiBannerPermanent?: boolean;
  uiBannerPosition?: string;
  uiBannerURL?: string;
  uiCssURL?: string;
  url?: string;
  userLoginsDisabled?: boolean;
}

export type ClusterOIDCConfigIdTokenClaims = {[key: string]: OidcClaim};

export interface ClusterOIDCConfig {
  cliClientID?: string;
  clientID?: string;
  enablePKCEAuthentication?: boolean;
  idTokenClaims?: ClusterOIDCConfigIdTokenClaims;
  issuer?: string;
  name?: string;
  scopes?: string[];
}

export type ClusterHelpBinaryUrls = {[key: string]: string};

export interface ClusterHelp {
  binaryUrls?: ClusterHelpBinaryUrls;
  chatText?: string;
  chatUrl?: string;
}

export interface ClusterGoogleAnalyticsConfig {
  anonymizeUsers?: boolean;
  trackingID?: string;
}

export interface ClusterConnector {
  name?: string;
  type?: string;
}

export interface ClusterDexConfig {
  connectors?: ClusterConnector[];
}

export interface ClusterClusterResponse { [key: string]: any }

export interface ClusterClusterID {
  type?: string;
  value?: string;
}

export interface Applicationv1alpha1EnvEntry {
  name?: string;
  value?: string;
}

export interface ApplicationsetApplicationSetResponse {
  applicationset?: V1alpha1ApplicationSet;
  project?: string;
}

export interface ApplicationSyncOptions {
  items?: string[];
}

export interface ApplicationResourceActionsListResponse {
  actions?: V1alpha1ResourceAction[];
}

export interface ApplicationOperationTerminateResponse { [key: string]: any }

export interface ApplicationManagedResourcesResponse {
  items?: V1alpha1ResourceDiff[];
}

export interface ApplicationLogEntry {
  content?: string;
  last?: boolean;
  podName?: string;
  timeStamp?: V1Time;
  timeStampStr?: string;
}

export interface ApplicationLinkInfo {
  description?: string;
  iconClass?: string;
  title?: string;
  url?: string;
}

export interface ApplicationLinksResponse {
  items?: ApplicationLinkInfo[];
}

export interface ApplicationFileChunk {
  chunk?: string;
}

export interface ApplicationApplicationSyncWindow {
  duration?: string;
  kind?: string;
  manualSync?: boolean;
  schedule?: string;
}

export interface ApplicationApplicationSyncWindowsResponse {
  activeWindows?: ApplicationApplicationSyncWindow[];
  assignedWindows?: ApplicationApplicationSyncWindow[];
  canSync?: boolean;
}

export interface ApplicationApplicationSyncRequest {
  appNamespace?: string;
  dryRun?: boolean;
  infos?: V1alpha1Info[];
  manifests?: string[];
  name?: string;
  project?: string;
  prune?: boolean;
  resources?: V1alpha1SyncOperationResource[];
  retryStrategy?: V1alpha1RetryStrategy;
  revision?: string;
  revisions?: string[];
  sourcePositions?: string[];
  strategy?: V1alpha1SyncStrategy;
  syncOptions?: ApplicationSyncOptions;
}

export interface ApplicationApplicationRollbackRequest {
  appNamespace?: string;
  dryRun?: boolean;
  id?: number;
  name?: string;
  project?: string;
  prune?: boolean;
}

export interface ApplicationApplicationResponse { [key: string]: any }

export interface ApplicationApplicationResourceResponse {
  manifest?: string;
}

export interface ApplicationApplicationPatchRequest {
  appNamespace?: string;
  name?: string;
  patch?: string;
  patchType?: string;
  project?: string;
}

export interface ApplicationApplicationManifestQueryWithFiles {
  appNamespace?: string;
  checksum?: string;
  name?: string;
  project?: string;
}

export interface ApplicationApplicationManifestQueryWithFilesWrapper {
  chunk?: ApplicationFileChunk;
  query?: ApplicationApplicationManifestQueryWithFiles;
}

export interface AccountUpdatePasswordResponse { [key: string]: any }

export interface AccountUpdatePasswordRequest {
  currentPassword?: string;
  name?: string;
  newPassword?: string;
}

export interface AccountToken {
  expiresAt?: number;
  id?: string;
  issuedAt?: number;
}

export interface AccountEmptyResponse { [key: string]: any }

export interface AccountCreateTokenResponse {
  token?: string;
}

export interface AccountCreateTokenRequest {
  expiresIn?: number;
  id?: string;
  name?: string;
}

export interface AccountCanIResponse {
  value?: string;
}

export interface AccountAccount {
  capabilities?: string[];
  enabled?: boolean;
  name?: string;
  tokens?: AccountToken[];
}

export interface AccountAccountsList {
  items?: AccountAccount[];
}

